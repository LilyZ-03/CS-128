{"config":{"output_file":null,"full_docs":false,"pub_only":false,"reachable_only":false,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.1","compilation":{"directory":"/Users/welby/c/school/cs128/rust_hw_5","program":"/Users/welby/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rls","arguments":[],"output":"/Users/welby/c/school/cs128/rust_hw_5/target/rls/debug/deps/libhw5-a42c91e110f36c70.rmeta"},"prelude":{"crate_id":{"name":"hw5","disambiguator":[16642444722513714733,7654514934009028887]},"crate_root":"src","external_crates":[{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[11266178634318078844,10430434914575217037]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[11698766721189094488,12060600386163665861]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[7682173449702177568,11032960836976215208]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[4743338922599007115,7423637119316760057]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[2427264904945132901,10184032034968735412]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[9774951351864599068,14817832832842499961]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[10809433593918525561,458952361993985826]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[15028772050842969220,14160812736163645060]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":9,"id":{"name":"hashbrown","disambiguator":[6995225455969351707,4449664983666090491]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[8140348155906305511,16205222570971502248]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":11,"id":{"name":"rustc_demangle","disambiguator":[233178625001733801,10631967199943834554]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":12,"id":{"name":"addr2line","disambiguator":[1525994598401419908,3288373240607898362]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":13,"id":{"name":"gimli","disambiguator":[6171023582747105604,8380219937402072808]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":14,"id":{"name":"object","disambiguator":[16379221974889702373,16836676840445794723]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":15,"id":{"name":"panic_unwind","disambiguator":[17037182358159064978,13693302728723089691]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":16,"id":{"name":"test","disambiguator":[5568651502090129804,7601781075051519962]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":17,"id":{"name":"getopts","disambiguator":[4467488556284040664,14752856029059701235]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":18,"id":{"name":"rustc_std_workspace_std","disambiguator":[10383272901569367485,2183551964930116157]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":19,"id":{"name":"unicode_width","disambiguator":[4304159073849980720,4706093947982292948]}},{"file_name":"/Users/welby/c/school/cs128/rust_hw_5/src/lib.rs","num":20,"id":{"name":"term","disambiguator":[13402756353203699848,15287256508391871388]}}],"span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":1075,"line_start":1,"line_end":25,"column_start":1,"column_end":2}},"imports":[],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":1075,"line_start":1,"line_end":25,"column_start":1,"column_end":2},"name":"","qualname":"::","value":"src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":6}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Local","id":{"krate":0,"index":1073741827},"span":{"file_name":"src/lib.rs","byte_start":252,"byte_end":257,"line_start":5,"line_end":5,"column_start":19,"column_end":24},"name":"cards","qualname":"::mark_cards::cards","value":"&mut std::vec::Vec<std::string::String>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":3},"span":{"file_name":"src/lib.rs","byte_start":241,"byte_end":251,"line_start":5,"line_end":5,"column_start":8,"column_end":18},"name":"mark_cards","qualname":"::mark_cards","value":"pub fn mark_cards(&mut Vec<String>)","parent":null,"children":[],"decl_id":null,"docs":" TODO: Implement the mark_cards function\n Marks every 3rd card by adding M to the front of the card's \n string representation (irrespective of if it already has a M or not)\n Make sure to derefence cards before changing it\n","sig":null,"attributes":[{"value":"/ TODO: Implement the mark_cards function","span":{"file_name":"src/lib.rs","byte_start":0,"byte_end":43,"line_start":1,"line_end":1,"column_start":1,"column_end":44}},{"value":"/ Marks every 3rd card by adding M to the front of the card's ","span":{"file_name":"src/lib.rs","byte_start":44,"byte_end":108,"line_start":2,"line_end":2,"column_start":1,"column_end":65}},{"value":"/ string representation (irrespective of if it already has a M or not)","span":{"file_name":"src/lib.rs","byte_start":109,"byte_end":181,"line_start":3,"line_end":3,"column_start":1,"column_end":73}},{"value":"/ Make sure to derefence cards before changing it","span":{"file_name":"src/lib.rs","byte_start":182,"byte_end":233,"line_start":4,"line_end":4,"column_start":1,"column_end":52}}]},{"kind":"Local","id":{"krate":0,"index":1073741828},"span":{"file_name":"src/lib.rs","byte_start":792,"byte_end":797,"line_start":16,"line_end":16,"column_start":23,"column_end":28},"name":"cards","qualname":"::perfect_bridge::cards","value":"&std::vec::Vec<std::string::String>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4},"span":{"file_name":"src/lib.rs","byte_start":777,"byte_end":791,"line_start":16,"line_end":16,"column_start":8,"column_end":22},"name":"perfect_bridge","qualname":"::perfect_bridge","value":"pub fn perfect_bridge(&Vec<String>) -> Vec<String>","parent":null,"children":[],"decl_id":null,"docs":" TODO: Implement the perfect_bridge function\n Takes a Vector of strings representing a deck of cards (will always have an even number) \n Divides the deck into two parts at the middle, then shuffles the cards \n Such that the first card of the first half resides in the 0th position \n and the first card of the second hald resides in the 1th position\n And the second card of the first half resides in the 3rd position etc.\n After shuffling return the deck\n","sig":null,"attributes":[{"value":"/ TODO: Implement the perfect_bridge function","span":{"file_name":"src/lib.rs","byte_start":295,"byte_end":342,"line_start":9,"line_end":9,"column_start":1,"column_end":48}},{"value":"/ Takes a Vector of strings representing a deck of cards (will always have an even number) ","span":{"file_name":"src/lib.rs","byte_start":343,"byte_end":436,"line_start":10,"line_end":10,"column_start":1,"column_end":94}},{"value":"/ Divides the deck into two parts at the middle, then shuffles the cards ","span":{"file_name":"src/lib.rs","byte_start":437,"byte_end":512,"line_start":11,"line_end":11,"column_start":1,"column_end":76}},{"value":"/ Such that the first card of the first half resides in the 0th position ","span":{"file_name":"src/lib.rs","byte_start":513,"byte_end":588,"line_start":12,"line_end":12,"column_start":1,"column_end":76}},{"value":"/ and the first card of the second hald resides in the 1th position","span":{"file_name":"src/lib.rs","byte_start":589,"byte_end":658,"line_start":13,"line_end":13,"column_start":1,"column_end":70}},{"value":"/ And the second card of the first half resides in the 3rd position etc.","span":{"file_name":"src/lib.rs","byte_start":659,"byte_end":733,"line_start":14,"line_end":14,"column_start":1,"column_end":75}},{"value":"/ After shuffling return the deck","span":{"file_name":"src/lib.rs","byte_start":734,"byte_end":769,"line_start":15,"line_end":15,"column_start":1,"column_end":36}}]},{"kind":"Local","id":{"krate":0,"index":1073741829},"span":{"file_name":"src/lib.rs","byte_start":1034,"byte_end":1039,"line_start":23,"line_end":23,"column_start":15,"column_end":20},"name":"cards","qualname":"::runner::cards","value":"&mut std::vec::Vec<std::string::String>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5},"span":{"file_name":"src/lib.rs","byte_start":1027,"byte_end":1033,"line_start":23,"line_end":23,"column_start":8,"column_end":14},"name":"runner","qualname":"::runner","value":"pub fn runner(&mut Vec<String>)","parent":null,"children":[],"decl_id":null,"docs":" TODO: Implement the runner function\n Takes a vector of strings representing a deck of cards\n Shuffle the cards, then mark the cards, and finally shuffle them again\n","sig":null,"attributes":[{"value":"/ TODO: Implement the runner function","span":{"file_name":"src/lib.rs","byte_start":846,"byte_end":885,"line_start":20,"line_end":20,"column_start":1,"column_end":40}},{"value":"/ Takes a vector of strings representing a deck of cards","span":{"file_name":"src/lib.rs","byte_start":886,"byte_end":944,"line_start":21,"line_end":21,"column_start":1,"column_end":59}},{"value":"/ Shuffle the cards, then mark the cards, and finally shuffle them again","span":{"file_name":"src/lib.rs","byte_start":945,"byte_end":1019,"line_start":22,"line_end":22,"column_start":1,"column_end":75}}]}],"impls":[],"refs":[{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":264,"byte_end":267,"line_start":5,"line_end":5,"column_start":31,"column_end":34},"ref_id":{"krate":5,"index":6703}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":268,"byte_end":274,"line_start":5,"line_end":5,"column_start":35,"column_end":41},"ref_id":{"krate":5,"index":7216}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":800,"byte_end":803,"line_start":16,"line_end":16,"column_start":31,"column_end":34},"ref_id":{"krate":5,"index":6703}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":804,"byte_end":810,"line_start":16,"line_end":16,"column_start":35,"column_end":41},"ref_id":{"krate":5,"index":7216}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":816,"byte_end":819,"line_start":16,"line_end":16,"column_start":47,"column_end":50},"ref_id":{"krate":5,"index":6703}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":820,"byte_end":826,"line_start":16,"line_end":16,"column_start":51,"column_end":57},"ref_id":{"krate":5,"index":7216}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":1046,"byte_end":1049,"line_start":23,"line_end":23,"column_start":27,"column_end":30},"ref_id":{"krate":5,"index":6703}},{"kind":"Type","span":{"file_name":"src/lib.rs","byte_start":1050,"byte_end":1056,"line_start":23,"line_end":23,"column_start":31,"column_end":37},"ref_id":{"krate":5,"index":7216}}],"macro_refs":[],"relations":[]}